# ReactJS de Básico a Avanzado

![logo](https://transparencia.banxico.org.mx/dyn/multimedia/bannerT.jpg)

> Alan Badillo Salas (badillosalas@outlook.com)

```markdown
Módulo III: Composición vs Herencia

1. Principios de composición en React
2. Cuándo usar composición en lugar de herencia
```
## M301. Principios de composición en React

En *React*, la composición es el mecanismo principal para reutilizar código entre componentes.

En lugar de usar herencia (como en la **POO** clásica), React fomenta el uso de componentes pequeños y especializados que se combinan para formar interfaces más complejas.

### 1. Componete clase contra Componente funcional

> Componente clase:

```jsx
import React from "react"

// Define un componente clase 
// derivado de React.Component
export default class Counter extends React.Component {
    // En el constructor se reciben los props
    constructor(props) {
        // Se inicializa la clase base
        // (React.Component) con los props propagados
        super(props)
        // Se inicializa el estado
        this.state = { 
            count: 0 
        }
    }

    // Se auto-enlaza el controlador
    // Nota: Si es método estándar:
    // Se debe realizar (en el constructor)
    // this.increment = this.increment.bind(this)
    increment = () => {
        // prev.count <=> this.state.count
        this.setState(
            prev => ({
                // Actualización del estado parcial
                count: prev.count + 1 
            })
        )
    }

    // Método de refrescado (renderizado)
    render() {
        // Componente devuelto (render)
        return (
            <div>
                <h1>{this.state.count}</h1>
                <button 
                    onClick={this.increment}
                >
                    Incrementar
                </button>
            </div>
        )
    }
}
```

Ventajas:

* Encapsulan mejor el código
* Mantienen la filosofía de la **POO**
* Se apegan al ciclo de vida estándar
* Tienen un mejor control del estado

Desventajas
* Son más verbosos
* Complican el control de estados (rastreo)
* Son menos reutilizables
* La lógica y el componente quedan altamente acoplados (fusionados)

> Componente funcional:

```jsx
import { useState } from "react"

// Define un componente funcional
export default function Counter() {
    // useState devuelve un estado actual 
    // y una función para actualizarlo
    const [count, setCount] = useState(0)

    // Función manejadora
    const increment = () => {
        // Se actualiza el estado con el nuevo valor
        setCount(prev => prev + 1)
    }

    // Renderizado
    return (
        <div>
            <h1>{count}</h1>
            <button onClick={increment}>
                Incrementar
            </button>
        </div>
    )
}
```

Ventajas:

* Código más conciso y claro.
* Permiten separar lógica de estado en *hooks* reutilizables.
* Son el estándar moderno en React (las clases aún funcionan, pero se usan cada vez menos).
* Mejor integración con **React 18/19** (Concurrent Mode, Server Components, Suspense).

Desventajas:

* Código con estados inyectados mediante *hooks*, si hay abuso, la sincronización de estados es un poco más complicada
* Uso de efectos sustituyen el ciclo de vida y complican un poco la detección de dependencias en los cambios
* Pueden surgir problemas de hidratación si no se controla el uso de hooks dependientes del navegador.

#### Diferencias clave

Aspecto | Componente Clase | Componente Funcional
--- | --- | ---
**Definición** | Extiende `React.Component` | Función de JavaScript normal
**Estado** | Manejado con `this.state` y `this.setState` | Manejado con Hooks (`useState`, `useReducer`)
**Ciclo de vida** | Usa métodos especiales (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`) | Usa Hooks de efecto (`useEffect`)
**Verbosidad** | Más código (`constructor`, `this`, `bind`, etc.) | Más conciso y legible
**Reutilización de lógica** | Difícil de extraer sin herencia o `HOCs` | Sencillo gracias a *custom hooks*
**Rendimiento** | Leve sobrecarga (por instanciación de clase) | Más ligero y optimizado

### 2. Composición mediante props.children

Un componente puede recibir otros componentes o elementos como hijos:

```jsx
function Card(props) {
    return (
        <div className="card">
            {props.children}
        </div>
    )
}

function App() {
    return (
        <Card>
            <h2>Título de la tarjeta</h2>
            <p>Contenido de la tarjeta</p>
        </Card>
    )
}
```

Aquí, Card es un contenedor genérico, y su contenido se define desde afuera.

### 3. Composición con props personalizadas

Se pueden pasar `props` específicas para construir variaciones de un componente.

```jsx
function Dialog({ title, message }) {
    return (
        <div className="dialog">
            <h1>{title}</h1>
            <p>{message}</p>
        </div>
    )
}

function App() {
  return (
        <Dialog 
            title="Bienvenido" 
            message="Gracias por visitar nuestra página" 
        />
    )
}
```

Aquí la composición está delegada al valor de las propiedades.

### 4. Composición con funciones o elementos como props

Incluso es posible pasar funciones o elementos completos para mayor flexibilidad:

```jsx
function Layout({ header, content, footer }) {
    return (
        <div>
            <header>{header}</header>
            <main>{content}</main>
            <footer>{footer}</footer>
        </div>
    )
}

function App() {
    return (
        <Layout
            header={<h1>Encabezado</h1>}
            content={<p>Contenido principal</p>}
            footer={<small>Pie de página</small>}
        />
    )
}
```

Con esto, React facilita la creación de patrones de diseño reutilizables.

## M202. Cuándo usar composición en lugar de herencia

En la mayoría de los casos, React recomienda composición porque:

1. **Mayor flexibilidad** - La composición permite que un componente sea un contenedor genérico al que se le inyecta contenido, en lugar de forzar una jerarquía rígida.
2. **Reutilización sin acoplamiento** - Los componentes compuestos son independientes entre sí, a diferencia de la herencia que crea dependencias fuertes.
3. **Consistencia con el enfoque de React** - React está diseñado alrededor de la composición de componentes, no de jerarquías de clases complejas.

### ¿Por qué no usar herencia?

> Con herencia (POO tradicional):

```jsx
class Button extends React.Component {}
class PrimaryButton extends Button {}
class SecondaryButton extends Button {}
```

Esto puede complicar la jerarquía y limitar la flexibilidad.

> Con composición (React components):

```jsx
function Button({ children, variant }) {
    return (
        <button 
            className={`btn ${variant}`}
        >
            {children}
        </button>
    )
}

function App() {
    return (
        <>
            <Button variant="primary">Aceptar</Button>
            <Button variant="secondary">Cancelar</Button>
        </>
    )
}
```

Aquí, un solo componente flexible resuelve el problema con menos complejidad.

### Conclusión

* Usa **composición** para crear interfaces dinámicas y reutilizables.
* La **herencia** rara vez es necesaria en React, y normalmente se evita.